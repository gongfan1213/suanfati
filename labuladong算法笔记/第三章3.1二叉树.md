# 3.1二叉树

## 3.1.1 手把手带你刷二叉树思路

读完本节，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[104.二叉树的最大深度](，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[104.二叉树的最大深度](URL_ADDRESScode-cn.com/problems/maximum-depth-of-binary-tree)

[543.二叉树的直径](URL_ADDRESScode-cn.com/problems/diameter-of-binary-tree)

[226.翻转二叉树](URL_ADDRESScode-cn.com/problems/invert-binary-tree)

[114.二叉树展开为链表](URL_ADDRESScode-cn.com/problems/flatten-binary-tree-to-linked-list)

二叉树的解题的思维模式分为两类

1.是否可以通过遍历一遍二叉树得到答案？如果可以，用一个traverse函数配合外部变量来实现，这叫「遍历」的思维模式。

2.是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

## 1.翻转二叉树

我们先从简单的题开始，看看力扣第226题「翻转二叉树」，输入一个二叉树根节点root，让你把整棵树镜像翻转，比如输入的二叉树如下：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

算法原地翻转二叉树，使得以root为根的树变成：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

这道题不难对吧，只要把每一个节点的左右子节点进行交换，就能得到翻转后的二叉树。

```
TreeNode invertTree(TreeNode root) {
    // base case
    if (root == null) {
        return null;
    }

    /**** 前序遍历位置 ****/
    // root 节点需要交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 让左右子节点继续翻转它们的子节点
    invertTree(root.left);
    invertTree(root.right);

    return root;
}
```

```java
//主函数
public TreeNode invertTree(TreeNode root) {
    //遍历二叉树，交换每个节点的子节点
    traverse(root);
    return root; 
}
//二叉树遍历函数
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    /**** 前序遍历位置 ****/
    //每一个节点需要做的事就是交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    //遍历框架，去遍历左右子树的节点
    traverse(root.left);
    traverse(root.right);

}
```
你把前序位置的代码写在中间，就是中序遍历，后序位置的代码就写在最后，就是后序遍历，你可以发现，**前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的**。

2.这题能不能用分解问题的思路写出来，肯定可以的。

我们尝试给invertTree函数一个定义，**以root为根的这棵二叉树，我翻转它，**会返回翻转后的二叉树的根节点。
```java
TreeNode invertTree(TreeNode root) {
    // base case 
}
```

你把前序位置的代码移到后序位置也是可以的，但是直接移到中序位置是不行的，需要稍作修改，这应该很容易看出来的，我会留给你思考。

2，这题能不能用分解问题的思路写出来，肯定可以的。

我们尝试给invertTree函数一个定义，以root为根的这棵二叉树，我翻转它，会返回翻转后的二叉树的根节点。

```java
//定义：将以root为根的这棵二叉树翻转，返回翻转后的二叉树的根节点
TreeNode invertTree(TreeNode root) {
    
}
```

然后思考，对于某一个二叉树节点x执行invertTree(x)，会在什么时候执行？

执行invertTree(x)时，需要先递归执行invertTree(x.left)，再递归执行invertTree(x.right)，最后将x的左右子节点交换。
这恰好完成了以x为根的整棵二叉树的翻转，x就是根，所以这就是递归函数的定义。

按照这个定义，invertTree函数就会如下写：

```java
TreeNode invertTree(TreeNode root) {
    //base case
    if (root == null) {
        return null;
    }
    //利用定义，先翻转左右子树
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    //然后交换左右子节点
    root.left = right;
    root.right = left;

    //和定义逻辑自恰：以root为根的这棵二叉树已经被翻转，返回root
    return root; 
}
```
这种分解问题的思路，有时候叫「递归」的思维模式，我们以上两个问题就是经典的递归问题，主要思路就是**把一棵大问题分解为若干个子问题，通过递归函数的调用来解决子问题，然后合并子问题的解法，得出原问题的解法**。

核心在于你要给递归函数一个定义，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

## 2.填充每个节点的下一个右侧节点指针

这道题不难对吧，只要把每一个节点的左右子节点进行连接，就是一个完美二叉树，而且题目说了，输入是一棵「完美二叉树」，所以我们不用担心子节点不存在的情况。

力扣第116题「填充每个节点的下一个右侧节点指针」和第117题「填充每个节点的下一个右侧节点指针 II」就是这道题，它们的主要区别在于，第116题的输入是「满二叉树」，而第117题的输入是「普通二叉树」：

```java
// 116题，输入满二叉树
struct Node {
    int val;
    Node *left;
    Node *right;
    Node *next; 
}
```
